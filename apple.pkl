import "string.pkl"

class AppleStringRenderer extends string.StringRenderer {
    function render(localizable: string.Localizable): Mapping<String, FileOutput> = new Mapping {
        ["apple/Localizable.xcstrings"] = new FileOutput {
            renderer = new JsonRenderer {}
            value = new Localizable {
                sourceLanguage = localizable.sourceLanguage
                strings = mapStrings(
                    getKeys(localizable.languages, localizable.sourceLanguage),
                    localizable.languages
                )
            }
        }
    }

    local function mapStrings(
        keys: List<String>, 
        languages: List<string.Language>
    ): Mapping<String, LocalizableString> = new Mapping {
        for (key in keys) {
            [key] = new LocalizableString {
                localizations = mapLanguageStrings(getStringInLanguages(key, languages))
            }
        }
    }

    local function mapLanguageStrings(
        strings: List<StringLanguagePair>
    ): Mapping<String, StringLocalization> = new Mapping {
        for (s in strings) {
            [s.code] = if (s.string is string.SingleResourceString)
                mapSingleString(s.string)
            else
                mapPluralString(s.string)
        }
    }

    local function mapSingleString(s: string.SingleResourceString): StringLocalization = new StringLocalization {
        stringUnit = new StringUnit {
            value = s.value
        }
    }

    local function mapPluralString(s: string.QuantityResourceString): StringLocalization = _mapPluralString(s, replaceFirstDigit(s.first()))

    local function _mapPluralString(s: string.QuantityResourceString, f: FirstDigitInformation): StringLocalization = new StringLocalization {
        stringUnit = new StringUnit {
            value = f.transformed
        }
        substitutions = new Mapping {
            ["arg1"] = new Substitution {
                argNum = f.position
                formatSpecifier = f.formatChar
                variations = new Variations {
                    plural = new Mapping {
                        for (option in s.options) {
                            [option.quantity] = new StringLocalization {
                                stringUnit = new StringUnit {
                                    value = replaceFirstDigit(option.value).transformed
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    local function getStringInLanguages(
        key: String,
        languages: List<string.Language>
    ): List<StringLanguagePair> = languages.flatMap(
        (l) -> l.strings.filter((s) -> s.name == key).map((s) -> new StringLanguagePair {
            string = s
            code = l.code ?? defaultLanguage
        })
    )

    local function getKeys(
        languages: List<string.Language>,
        sourceLanguage: String
    ): List<String> = languages.filter((l) -> l.code == sourceLanguage).flatMap((l) -> l.strings.map((s) -> s.name))

    local function replaceFirstDigit(value: String): FirstDigitInformation = _replaceFirstDigit(
        value, 
        Regex("%(\\d)\\$([dDuUxXfeEgGcC])").findMatchesIn(value).firstOrNull,
        Regex("%([dDuUxXfeEgGcC])").findMatchesIn(value).firstOrNull
    )

    local function _replaceFirstDigit(value: String, specifiedMatch: RegexMatch?, positionalMatch: RegexMatch?): FirstDigitInformation = if (specifiedMatch != null)
        new FirstDigitInformation {
            transformed = value.replaceAll("%\(specifiedMatch.groups[1].value)$\(specifiedMatch.groups[2].value)", "%#@arg1@")
            formatChar = specifiedMatch.groups[2].value
            position = specifiedMatch.groups[1].value.toInt()
        } 
    else 
        new FirstDigitInformation {
            transformed = value.replaceFirst("%[dDuUxXfeEgGcC]", "%#@arg1@")
            formatChar = positionalMatch?.groups[0]?.value ?? throw("Plural strings must haveat least one digit parameter")
        } 
        
}

class Localizable {
    sourceLanguage: String = "en"
    strings: Mapping<String, LocalizableString>
    version: String = "1.0"
}

class LocalizableString {
    extractionState: String = "manual"
    comment: String?
    localizations: Mapping<String, StringLocalization>
}

class StringLocalization {
    stringUnit: StringUnit?
    substitutions: Mapping<String, Substitution>?
    variations: Variations?
}

class StringUnit {
    state: String = "translated"
    value: String
}

class Substitution {
    argNum: Int
    formatSpecifier: String
    variations: Variations
}

class Variations {
    plural: Mapping<string.Quantity, StringLocalization>
}

local class StringLanguagePair {
    string: string.ResourceString
    code: String
}

local class FirstDigitInformation {
    position: Int = 1
    formatChar: String
    transformed: String
}