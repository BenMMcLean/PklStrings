open module schema

typealias Quantity = "zero" | "one" | "two" | "few" | "many" | "other"

abstract class StringRenderer {

    platformName: String

    abstract function render(localizable: Localizable): Mapping<String, FileOutput>

}

class Localizable {
    sourceLanguage: String = "en"
    languages: Listing<Language>(checkKeysMatchSourceLanguage(this, getKeysForLanguage(this, sourceLanguage).toList()))
}

class Language {
    code: String
    strings: Listing<ResourceString>
}

abstract class ResourceString {
    name: String(matches(Regex("^[a-z_][a-z\\d_]*$")))
}

class SingleResourceString extends ResourceString {
    value: String
    platformValue: Mapping<String, String>?

    function get(platformName: String): String = platformValue?.getOrNull(platformName) ?? value
}

class QuantityResourceString extends ResourceString {
    options: Listing<QuantityOption>(length > 0)

    function first(platformName: String): String = options[0].get(platformName)
}

class QuantityOption {
    quantity: Quantity
    value: String
    platformValue: Mapping<String, String>?

    function get(platformName: String): String = platformValue?.getOrNull(platformName) ?? value
}

const function checkKeysMatchSourceLanguage(languages: Listing<Language>, keys: List<String>): Boolean =
    !languages.toList().map(
        (s) -> s.strings.toList().fold(true, (r,e) -> r && keys.contains(e.name))
    ).any((b) -> !b)

const function getKeysForLanguage(
    languages: Listing<Language>,
    sourceLanguage: String
): List<String> = languages.toList()
    .filter((l) -> l.code == sourceLanguage).flatMap((l) -> l.strings.toList().map((s) -> s.name))